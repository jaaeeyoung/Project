/*
=======================================================================================================================================
+ 문제 제목 +
=======================================================================================================================================
' 큰 수 만들기 ☆☆
=======================================================================================================================================
+ 문제 설명 +
=======================================================================================================================================
' 어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다.
' 예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24]를 만들 수 있습니다. 이 중 가장 큰 숫자는 94입니다.
' 문자열 형식으로 숫자 number와 제거할 수의 개수 k가 solution 함수의 매개변수로 주어집니다. number에서 k개의 수를 제거했을 때 만들 수 있는 수
  중 가장 큰 숫자를 문자열 형태로 return 하도록 solution 함수를 완성하세요.
=======================================================================================================================================
+ 제한 사항 +
=======================================================================================================================================
' number는 1자리 이상, 1,000,000자리 이하인 숫자입니다.
' k는 1이상 number의 자릿수 미만인 자연수입니다.
=======================================================================================================================================
+ 입출력 예 +
=======================================================================================================================================
' number : "1924", k : 2, return : "94"
' number : "1231234", k : 3, return : "3234"
' number : "4177252841", k : 4, return : "775841"
=======================================================================================================================================
+ 입출력 예 설명 +
=======================================================================================================================================
' 
=======================================================================================================================================
+ 수정 기록 +
=======================================================================================================================================
' 2021-03-13-Sat : 코딩 시작
                   number 배열의 자리가 변하지 않도록 다시 코딩해야함
=======================================================================================================================================
*/

#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>

// 파라미터로 주어지는 문자열은 const로 주어집니다. 변경하려면 문자열을 복사해서 사용하세요.
char *solution(const char *number, int k)
{
    // return 값은 malloc 등 동적 할당을 사용해주세요. 할당 길이는 상황에 맞게 변경해주세요.
    char *answer = (char *)malloc(1);
    char temp[7] = {0};
    char tmp = 0;
    int num = 0;
    int sum = 0;
    int split[7] = {0};
    int max=0;
    int max_idx = 0;
    int a = 0;
    int b = 0;
    int i = 0;

    // temp 배열에 number 배열 복사
    for (int i = 0; i < sizeof(number); i++)
    {
        temp[i] = number[i];
    }

    // temp 배열 오름차순 정렬
    /*
    for(int i=0;i<sizeof(temp)-1;i++){
        for(int j=i+1;j<sizeof(temp);j++){
            if(temp[i]>temp[j]){ // temp의 왼쪽 원소가 오른쪽 원소보다 큰 경우 자리 바꿈
                tmp = temp[i];
                temp[i]=temp[j];
                temp[j]=tmp;
            }
        }
    }
    */
    /*
    // temp 배열에서 k 개수만큼 앞에서 부터 삭제
    for(int i=0;i<k;i++){
        for(int j=0;j<sizeof(temp)-1;j++){
            temp[j]=temp[j+1];
        }
        temp[sizeof(temp)-i-1]='\0';
    }*/

    num = atoi(temp); // char 형 temp배열의 숫자형 문자를 숫자로 변환해 num에 저장
    a = num;
    i = 0;
    // num의 각 자리수를 split 배열에 저장 (int형)
    while (1)
    {
        split[i] = a % 10;
        a /= 10;
        if (a < 10)
        {
            split[i + 1] = a;
            break;
        }
        i++;
    }

    // split 배열 원소 위치 원위치
    tmp=0;
    for(int i=0;i<sizeof(split)/8;i++){
        tmp=split[i];
        split[i]=split[sizeof(split)/4-i-1];
        split[sizeof(split)/4-i-1]=tmp;
    }

    for(int i=0;i<sizeof(split)/4;i++){
        printf("split[%d] = %d\n", i, split[i]);
    }

    // 가능 한 숫자의 유형 모두 출력
    for(int i=0;i<sizeof(number)-k;i++){
        for(int j=0;j<sizeof(split)/4-k;j++){
            
            for(int l=j;l<sizeof(split)/4;l++){
                sum=0;
                for(int z=0;z<sizeof(split)/4-k-l-1;z++){
                    split[l]=split[l]*10;
                }
                sum=sum+split[l];
            }
            printf("sum : \n%d\n", sum);
        }
    }
    // split 배열에서 가장 큰 수 찾기
    /*
    max = split[0];
    for (int i = 0; i < sizeof(split) / 4 - k; i++)
    {
        printf("hi\n");
        if (max < split[i])
        {
            max = split[i];
            max_idx = i;
            printf("max = %d\nmax_idx = %d\n", split[i], max_idx);
        }
    }
    printf("max = %d\n", max);
    */
    /*
    if (sizeof(split) / 4 - max_idx - 1 == k)
    { // split배열에서 가장 큰 수부터 끝까지의 원소 개수가 k와 같으면
        for (int i = max_idx; i < sizeof(split); i++)
        {
            num = num + split[i] * 10 * (k - i - 1);
            if (i == k - 1)
            {
                num += split[i];
                break;
            }
        }
    }
    */
    // split 배열 내림차순
    /*
    for(int i=0;i<sizeof(split)/4-1;i++){
        for(int j=i;j<sizeof(split)/4;j++){
            if(split[i]<split[j]){
                tmp=split[i];
                split[i]=split[j];
                split[j]=tmp;
            }
        }
    }
    */

    // split 배열에서 가장 큰 수 부터 k개 만큼의 수로 숫자 만들기
    num = 0;
    for (int i = 0; i < k; i++)
    {
        num = num + split[i] * 10 * (k - i - 1);
        if (i == k - 1)
        {
            num += split[i];
            break;
        }
    }

    itoa(num, answer, 10); // itoa(int 변수, 저장할 변수, 진수)
    return answer;
}

int main(void)
{
    printf("%s\n", solution("1231234", 3));
}