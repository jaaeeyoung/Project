/*
=======================================================================================================================================
+ 문제 제목 +
=======================================================================================================================================
' 스킬트리 ☆☆
=======================================================================================================================================
+ 문제 설명 +
=======================================================================================================================================
' 선행 스킬이란 어떤 스킬을 배우기 전에 먼저 배워야 하는 스킬을 뜻합니다.
' 예를 들어 선행 스킬 순서가 스파크 > 라이트닝 볼트 > 썬더 일 때, 썬더를 배우려면 먼저 라이트닝 볼트를 배워야 하고, 라이트닝 볼트를 배우려면
  먼저 스파크를 배워야 합니다.
' 위 순서에 없는 다른 스킬(힐링 등)은 순서에 상관없이 배울 수 있습니다. 따라서 스파크 > 힐링 > 라이트닝 볼트 > 썬더 와 같은 스킬트리는 가능하
  지만, 썬더 > 스파크 나 라이트닝 볼트 > 스파크 > 힐링 > 썬더 와 같은 스킬트리는 불가능합니다.
' 선행 스킬 순서 skill과 유저들이 만든 스킬트리(유저가 스킬을 배울 순서)를 담은 배열 skill_trees가 매개변수로 주어질 때, 가능한 스킬트리 개수
  를 return 하는 solution 함수를 작성해주세요.
=======================================================================================================================================
+ 제한 사항 +
=======================================================================================================================================
' 스킬은 알파벳 대문자로 표기하며, 모든 문자열은 알파벳 대문자로만 이루어져 있습니다.
' 스킬 순서와 스킬트리는 문자열로 펴기합니다.
  예를 들어 C > B > D라면 "CBD"로 표기합니다.
' 선행 스킬 순서 skill의 길이는 1 이상 26 이하이며, 스킬은 중복해 주어지지 않습니다.
' skill_trees는 길이 1 이상 20 이하인 배열입니다.
' skill_trees의 원소는 스킬을 나타내는 문자열입니다.
' skill_trees의 원소는 길이가 2 이상 26 이하인 문자열이며, 스킬이 중복해 주어지지 않습니다.
=======================================================================================================================================
+ 입출력 예 +
=======================================================================================================================================
  skill                 skill_trees                  return
  "CDB"     ["BACDE", "CBADF", "AECB", "BDA"]          2
=======================================================================================================================================
+ 입출력 예 설명 +
=======================================================================================================================================
' "BACDE" : B 스킬을 배우기 전에 C 스킬을 먼저 배워야 합니다.불가능한 스킬트립니다.
' "CBADF" : 가능한 스킬트리입니다.
' "AECB" : 가능한 스킬트리입니다.
' "BDA" : B 스킬을 배우기 전에 C 스킬을 먼저 배워야 합니다. 불가능한 스킬트리입니다.
=======================================================================================================================================
+ 수정 기록 +
=======================================================================================================================================
' 2021-03-04 : 코딩 시작
' 2021-03-05 : 모두 지우고 재시작
               temp 배열 성공
               103번줄 for문 flag 씀으로서 제대로 동작하는지 확인 필요
=======================================================================================================================================
*/

#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>

// 파라미터로 주어지는 문자열은 const로 주어집니다. 변경하려면 문자열을 복사해서 사용하세요.
// skill_trees_len은 배열 skill_trees의 길이입니다.
//int solution(const char *skill, const char *skill_trees[], size_t skill_trees_len)
int main(void)
{
  int answer = 0;
  char temp[20][26] = {0};                                    // skill_trees 배열에 있는 원소 중 skill 배열에 포함되어 있는 원소만 빈칸없이 저장한 배열
  char skill[3] = {"CDB"};                                    // 삭제
  char skill_trees[4][5] = {"BACDE", "CBADF", "AECB", "BDA"}; // 삭제
  int skill_trees_len = 0;                                    // 삭제
  skill_trees_len = sizeof(skill_trees);                      // 삭제
  int count = 0;
  int flag = 0; // temp 배열과 skill 배열을 비교할 때 skill 배열의 index를 저장할 변수

  // temp 배열값 모두 Null로 설정
  for (int i = 0; i < sizeof(temp) / 26; i++)
  {
    for (int j = 0; j < sizeof(temp[i]); j++)
    {
      temp[i][j] = '\0';
    }
  }

  for (int i = 0; i < skill_trees_len / sizeof(skill_trees[i]); i++)
  { // skill_trees에 포함되어있는 스킬 중에서
    for (int j = 0; j < sizeof(skill_trees[i]); j++)
    { // skill_trees[i][j]로 모든 스킬 확인
      for (int k = 0; k < sizeof(skill); k++)
      { // skill로 정해져있는 배열
        if (skill_trees[i][j] == skill[k])
        {                                 // 만약 skill_trees에 skill에 포함되어있는 스킬이 있다면
          temp[i][j] = skill_trees[i][j]; // temp 배열에 복사
        }

        for (int l = 0; l < sizeof(temp) / 26; l++)
        { // temp 배열 전체를 검사
          if (temp[i][l] == '\0')
          {                              // temp 배열에 Null인 원소가 있다면
            temp[i][l] = temp[i][l + 1]; // 다음 원소의 값을 현재 원소에 복사하고
            temp[i][l + 1] = '\0';       // 다음 원소의 값을 Null 값으로 바꿔줌
          }
        }
      }
    }
  }

  for(int i=0;i<sizeof(temp)/sizeof(temp[i]);i++){
    for(int j=0;j<sizeof(temp[i]);j++){
      printf("temp[%d][%d] = %c\n", i, j, temp[i][j]);
    }
  }

  for (int i = 0; i < sizeof(temp) / sizeof(temp[i]); i++) // temp 배열 전체 원소 검사
  {
    count = 0;
    flag = 0;
    if (temp[i][0] != skill[0]) // temp의 각 행의 첫번째 원소의 값이 skill의 첫번째 원소와 다르면 바로 다음 행 검사
    {
      continue;
    }
    for (int j = 0; j < sizeof(temp[i]); j++)
    {
      for (int k = flag; k < sizeof(skill); k++)
      {
        if (temp[i][j] == skill[k])
        {          // temp의 각 행의 원소들과 skill의 원소와 비교해 같으면
          count++; // 숫자 count
          flag = k+1;
          continue;
        }
      }
    }

    if (count == sizeof(temp[i]))
    {           // 같은 원소의 개수와 temp 배열의 한 행의 길이와 같으면
      answer++; // answer 값 증가
    }
  }

  for (int i = 0; i < sizeof(temp) / 26; i++)
  {
    for (int j = 0; j < sizeof(temp[i]); j++)
    {
      //printf("temp[%d][%d] = %c\n", i, j, temp[i][j]); // 출력
    }
  }
  //return answer;
  printf("answer = %d\n", answer);
  return 0;
}